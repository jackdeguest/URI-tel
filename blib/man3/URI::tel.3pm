.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "URI::tel 3"
.TH URI::tel 3 "2018-03-31" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
URI::tel \- Implementation of rfc3966 for tel URI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    my $tel = URI::tel\->new( \*(Aqtel:+1\-418\-656\-9254;ext=102\*(Aq );
\&    ## or
\&    my $tel = URI::tel\->new( \*(Aqtel:5678\-1234;phone\-context=+81\-3\*(Aq );
\&    ## or
\&    my $tel = URI::tel\->new( \*(Aq03\-5678\-1234\*(Aq );
\&    $tel\->context( \*(Aq+81\*(Aq );
\&    $tel\->ext( 42 );
\&    print( $tel\->canonical\->as_string, "\en" );
\&    my $tel2 = $tel\->canonical;
\&    print( "$tel2\en" );
\&    ## or
\&    my $tel = URI::tel\->new( \*(Aq+1\-800\-LAWYERS\*(Aq );
\&    my $actualPhone = $tel\->aton;
\&    ## would produce +1\-800\-5299377
\&
\&    ## Comparing 2 telephones
\&    ## https://tools.ietf.org/search/rfc3966#section\-4
\&    if( $tel == $tel2 )
\&    {
\&        ## then do something
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`URI::tel\*(C'\fR is a package to implement the tel \s-1URI\s0
as defined in rfc3966 <https://tools.ietf.org/search/rfc3966>.
.PP
tel \s-1URI\s0 is structured as follows:
.PP
tel:\fItelephone-subscriber\fR
.PP
\&\fItelephone-subscriber\fR is either a \fIglobal-number\fR or a \fIlocal-number\fR
.PP
\&\fIglobal-number\fR can be composed of the following characters:
.PP
+[0\-9\e\-\e.\e(\e)]*[0\-9][0\-9\e\-\e.\e(\e)]* then followed with one or zero parameter, extension, isdn-subaddress
.PP
\&\fIlocal-number\fR can be composed of the following characters:
.PP
[0\-9A\-F\e*\e#\e\-\e.\e(\e)]* ([0\-9A\-F\e*\e#])[0\-9A\-F\e*\e#\e\-\e.\e(\e)]* followed by one or zero of 
parameter, extension, isdn-subaddress, then at least one context then followed by one or zero of 
parameter, extension, isdn-subaddress.
.PP
\&\fIparameter\fR is something that looks like ;[a\-zA\-Z0\-9\e\-]+=[\e[\e]\e/\e:\e&\e+\e$0\-9a\-zA\-Z\e\-\e_\e.\e!\e~\e*\e'\e(\e)]+
.PP
\&\fIextension\fR is something that looks like ;ext=[0\-9\e\-\e.\e(\e)]+
.PP
\&\fIisdn-subaddress\fR is something that looks like ;isub=[\e;\e/\e?\e:\e@\e&\e=\e+\e$\e,a\-zA\-Z0\-9\e\-\e_\e.\e!\e~\e*\e'\e(\e)%0\-9A\-F]+
.PP
\&\fIcontext\fR is something that looks like 
;phone\-context=([a\-zA\-Z0\-9]|[a\-zA\-Z0\-9][a\-zA\-Z0\-9\e\-]*[a\-zA\-Z0\-9]\e.)?([a\-zA\-Z]|[a\-zA\-Z][a\-zA\-Z0\-9\e\-]*[a\-zA\-Z0\-9])
or
;phone\-context=+([0\-9]+[\e\-\e.\e(\e)]*)?[0\-9]+([0\-9]+[\e\-\e.\e(\e)]*)?
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew\fR( tel \s-1URI \s0)" 4
.IX Item "new( tel URI )"
\&\fBnew\fR() is provided with a tel \s-1URI\s0 and return an instance of this package.
.IP "\fBas_string\fR()" 4
.IX Item "as_string()"
Returns a string representation of the tel uri. This package is overloaded, so one can get the same result by doing
.Sp
.Vb 1
\&    my $str = $tel\->as_string;
.Ve
.IP "\fBaton\fR( [ telephone ] )" 4
.IX Item "aton( [ telephone ] )"
If no phone number is given as argument, it will use the \fIsubscriber\fR value of the object used to call this method.
It returns the phone number with the letters replaced by their digit counterparts.
.Sp
For example a subscriber such as \f(CW\*(C`tel:+1\-800\-LAWYERS\*(C'\fR would return \f(CW\*(C`tel:+1\-800\-5299377\*(C'\fR
.IP "\fBcanonical\fR" 4
.IX Item "canonical"
Return the tel uri in a canonical form, ie without any visualisation characters, ie no \f(CW\*(C`hyphen\*(C'\fR, \f(CW\*(C`comma\*(C'\fR, \f(CW\*(C`dot\*(C'\fR, etc
.IP "\fBclone\fR()" 4
.IX Item "clone()"
Returns an exact copy of the current object.
.IP "\fBcontext\fR( [ \s-1CONTEXT \s0] )" 4
.IX Item "context( [ CONTEXT ] )"
Given a telephone context, sets the value accordingly.
It returns the current existing value.
.Sp
For example, with a phone number of 03\-1234\-5678, this is a local number, and one could set some context, such as
.Sp
.Vb 1
\&    $tel\->context( \*(Aq+81\*(Aq )
.Ve
.Sp
Thus, when called upon as a string, the object would return:
.Sp
.Vb 1
\&    03\-1234\-5678;phone\-context=+81
.Ve
.IP "\fBcountry\fR()" 4
.IX Item "country()"
If the current telephone uri is as global number, this method will try to find out to which country it belongs.
It returns an array in list context and an array reference in scalar context.
.Sp
If there are more than one country using the same international dialling code, it will return multiple entry in the array.
This is typically true for countries like Canada and the United States who both uses the same \f(CW+1\fR international dialling code.
.Sp
One could then do something like the following:
.Sp
.Vb 2
\&    my $ref = $tel\->country;
\&    print( "Country: ", @$ref > 1 ? join( \*(Aq or \*(Aq, map( $_\->{ \*(Aqname\*(Aq }, @$ref ) ) : @$ref ? $ref\->[0]\->{ \*(Aqname\*(Aq } : \*(Aqnot found\*(Aq, "\en" );
.Ve
.Sp
which would produce:
.Sp
.Vb 1
\&    Country: Canada or United States
.Ve
.Sp
Each array entry is a reference to an associative array, which contains the following fields:
.RS 4
.IP "\fIcc\fR for the iso 3166 2\-letters code" 8
.IX Item "cc for the iso 3166 2-letters code"
.PD 0
.IP "\fIcc3\fR for the iso 3166 3\-letters code" 8
.IX Item "cc3 for the iso 3166 3-letters code"
.IP "\fIname\fR for the country name" 8
.IX Item "name for the country name"
.IP "\fIidd\fR for the international dialling code. \fIidd\fR is an array reference which may contains one or more entries, as there may be multiple international dialling code per country." 8
.IX Item "idd for the international dialling code. idd is an array reference which may contains one or more entries, as there may be multiple international dialling code per country."
.RE
.RS 4
.RE
.IP "\fBis_global\fR()" 4
.IX Item "is_global()"
.PD
Returns true or false depending on whether the phone number is a global one, ie starting with \f(CW\*(C`+\*(C'\fR.
.IP "\fBis_local\fR()" 4
.IX Item "is_local()"
Returns true or false depending on whether the phone number is a local one, ie a number without the \f(CW\*(C`+\*(C'\fR prefix.
This can happen of course with numbers such as \f(CW\*(C`03\-1234\-5678\*(C'\fR, but also for emergency number, such as \f(CW110\fR (police in Japan) or
\&\f(CW911\fR (police in the U.S.).
.Sp
One could set a prefix to clarify, such as:
.Sp
.Vb 4
\&    my $tel = URI::tel\->new( \*(Aq110\*(Aq );
\&    $tel\->context( \*(Aq+81\*(Aq );
\&    ## which would produce:
\&    ## 110;phone\-context=+81
.Ve
.IP "\fBis_other\fR()" 4
.IX Item "is_other()"
Normally, as per rfc 3966, a non global number must have a context, but in everyday life this is rarely the case, so \fBis_other\fR flags those numbers who are local but lack a context.
.Sp
It returns true or false.
.IP "\fBis_vanity\fR()" 4
.IX Item "is_vanity()"
Returns true or false whether the telephone number is a vanity number, such as C+1\-800\-LAWYERS>.
.IP "\fBisub\fR( [ \s-1ISDN SUBADDRESS \s0] )" 4
.IX Item "isub( [ ISDN SUBADDRESS ] )"
Optionally sets the isdn subaddress if a value is provided.
It returns the current value set.
.Sp
.Vb 1
\&    $tel\->isub( 1420 );
.Ve
.IP "\fBoriginal\fR()" 4
.IX Item "original()"
Returns the original telephone number provided, before any possible changes were brought.
.IP "\fBprivate\fR( [ \s-1NAME,\s0 [ \s-1VALUE \s0] ] )" 4
.IX Item "private( [ NAME, [ VALUE ] ] )"
Given a \fI\s-1NAME\s0\fR, \fBprivate\fR returns the value entry for that parameter. If a \fI\s-1VALUE\s0\fR is provided, it will set this value for the given name.
if no \fI\s-1NAME\s0\fR, and no \fI\s-1VALUE\s0\fR was provided, \fBprivate\fR returns a list of all the name-value pair currently set, or a reference to that associative array in scalar context.
.IP "\fBsubscriber\fR( [ \s-1PHONE \s0] )" 4
.IX Item "subscriber( [ PHONE ] )"
Returns the current telephone number set for this telephone uri. For example:
.Sp
.Vb 2
\&    my $tel = URI::tel\->new( \*(Aqtel:+1\-418\-656\-9254;ext=102\*(Aq );
\&    my $subscriber = $tel\->subscriber;
.Ve
.Sp
will return: \f(CW\*(C`+1\-418\-656\-9254\*(C'\fR
.IP "\fBtype\fR()" 4
.IX Item "type()"
This is a read-only method. It returns the type of the telephone number. The type can be one of the following values: global, local, other, vanity
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2016\-2018 Jacques Deguest <\fIjack@deguest.jp\fR>
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
